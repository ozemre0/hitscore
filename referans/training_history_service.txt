import '../services/supabase_config.dart';
import '../models/training_session_model.dart';
import 'package:flutter/foundation.dart';
import 'package:sqflite/sqflite.dart';
import '../services/database_service.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'dart:io';
import 'dart:async'; // Timer iÃ§in gerekli

class TrainingHistoryService {
  /// Local ve Supabase arasÄ±nda Ã§ift yÃ¶nlÃ¼ training history senkronizasyonu
  /// - Sadece localde olup Supabase'de olmayanlarÄ± Supabase'e ekler
  /// - Sadece Supabase'de olup localde olmayanlarÄ± local'e ekler
  /// - Sadece gerÃ§ekten deÄŸiÅŸen antrenmanlarÄ± sync eder (updated_at kontrolÃ¼ ile)
  /// - Web platformunda local iÅŸlemleri atlar
  static final Map<String, DateTime> _lastSyncTime = {};
  static const Duration _minSyncInterval = Duration(minutes: 5);
  static bool _isSyncing = false;
  static DateTime? _lastGlobalSync;
  static const Duration _globalSyncCache = Duration(minutes: 10);

  // Senkronizasyon ihtiyacÄ±nÄ± kontrol et (Ã§ok sÄ±k senkronize etmeyi Ã¶nle)
  bool _shouldSync(String athleteId, {bool force = false}) {
    if (kIsWeb) return false; // Web'de local sync yok
    if (force) return true;

    if (!_lastSyncTime.containsKey(athleteId)) {
      return true; // Ä°lk senkronizasyon
    }

    final lastSync = _lastSyncTime[athleteId]!;
    final now = DateTime.now();
    return now.difference(lastSync) > _minSyncInterval;
  }

  // Senkronizasyon sonuÃ§larÄ± iÃ§in dÃ¶nÃ¼ÅŸ tipi deÄŸiÅŸtirildi
  Future<Map<String, dynamic>> syncTrainingHistoryWithSupabase(String athleteId,
      {bool force = false}) async {
    final now = DateTime.now();
    if (_isSyncing) {
       if (kDebugMode) debugPrint('|10n:sync_already_in_progress');
      return {
        'success': false,
        'info': 'sync_already_in_progress',
        'uploadedCount': 0,
        'downloadedCount': 0
      };
    }
    if (!force && _lastGlobalSync != null && now.difference(_lastGlobalSync!) < _globalSyncCache) {
      if (kDebugMode) debugPrint('|10n:sync_skipped_due_to_cache');
      return {
        'success': true,
        'info': 'sync_skipped_due_to_cache',
        'uploadedCount': 0,
        'downloadedCount': 0
      };
    }
    _isSyncing = true;
    _lastGlobalSync = now;
    if (kIsWeb) {
      if (kDebugMode) debugPrint('|10n:sync_web_only');
      return {
        'success': true,
        'info': 'web_platform_skip',
        'uploadedCount': 0,
        'downloadedCount': 0
      };
    }

    if (!force && !_shouldSync(athleteId)) {
      if (kDebugMode) debugPrint('Recent sync exists, skipping (use force=true to override)');
      return {
        'success': true,
        'info': 'recent_sync_exists',
        'uploadedCount': 0,
        'downloadedCount': 0
      };
    }

    _lastSyncTime[athleteId] = DateTime.now();
    await _handleDuplicateTrainingIds(athleteId);
    try {
      // Local verileri Ã§ek
      final localTrainings = await _db.getUserTrainingSessions(athleteId);
      // Supabase verilerini Ã§ek
      final supabaseTrainingsRaw = await _supabase
          .from('training_sessions')
          .select('*')
          .eq('user_id', athleteId)
          .eq('is_deleted', false); // Soft delete edilen antrenmanlarÄ± gÃ¶sterme
      final supabaseTrainings =
          List<Map<String, dynamic>>.from(supabaseTrainingsRaw);

      // id setleri oluÅŸtur
      final localIds = localTrainings.map((t) => t.id).toSet();
      final supabaseIds =
          supabaseTrainings.map((t) => t['id'] as String).toSet();

      if (kDebugMode) debugPrint(
          'Local trainings: ${localIds.length}, Supabase trainings: ${supabaseIds.length}');

      // Supabase'de mevcut antrenmanlarÄ± map olarak dÃ¼zenle (updated_at kontrolÃ¼ iÃ§in)
      final Map<String, Map<String, dynamic>> supabaseTrainingMap = {};
      for (final training in supabaseTrainings) {
        supabaseTrainingMap[training['id'] as String] = training;
      }

      // --- YENÄ° YAKLAÅIM: SADECE DEÄÄ°ÅENLERÄ° SYNC ET ---
      final List<TrainingSession> sessionsToInsert = []; // Yeni kayÄ±tlar
      final List<Map<String, dynamic>> sessionsToUpdate = []; // GÃ¼ncellenecek kayÄ±tlar
      int skippedCount = 0; // AtlanmÄ±ÅŸ (deÄŸiÅŸmeyen) kayÄ±t sayÄ±sÄ±

      for (final localSession in localTrainings) {
        if (localSession.id.startsWith('local_')) {
          // Local ID'leri her zaman ekle (yeni kayÄ±t)
          sessionsToInsert.add(localSession);
          if (kDebugMode) debugPrint('Marking local session for insert: ${localSession.id}');
        } else if (supabaseTrainingMap.containsKey(localSession.id)) {
          // Mevcut kayÄ±t - SADECE VERÄ° DEÄÄ°ÅÄ°KLÄ°ÄÄ° kontrolÃ¼ yap
          final supabaseVersion = supabaseTrainingMap[localSession.id]!;
          
          // **YENÄ° YAKLAÅIM: Timestamp yerine VERÄ° KARÅILAÅTIRMASI yap**
          // Ã‡Ã¼nkÃ¼ offline durumda timestamp'ler otomatik deÄŸiÅŸebiliyor
          bool needsUpdate = _hasDataChanges(localSession, supabaseVersion);
          
          if (needsUpdate) {
            if (kDebugMode) debugPrint('ğŸ’¡ GERÃ‡EK data changes detected: ${localSession.id}');
            final sessionData = localSession.toJson();
            sessionData.remove('series');
            sessionsToUpdate.add(sessionData);
          } else {
            // Hem timestamp hem de data aynÄ± - gerÃ§ekten deÄŸiÅŸiklik yok
            if (kDebugMode) debugPrint('âœ… No changes (data identical): ${localSession.id}');
            skippedCount++;
          }
        } else {
          // Sadece localde var - Supabase'e ekle
          final sessionData = localSession.toJson();
          sessionData.remove('series');
          sessionsToUpdate.add(sessionData);
          if (kDebugMode) debugPrint('Marking for upload to Supabase: ${localSession.id}');
        }
      }

      // Sadece Supabase'de olanlar (local'e eklenecek)
      final onlySupabase =
          supabaseTrainings.where((t) => !localIds.contains(t['id'])).toList();

      if (kDebugMode) debugPrint(
          'Sync summary: ${sessionsToInsert.length} new, ${sessionsToUpdate.length} updates, $skippedCount skipped, ${onlySupabase.length} downloads');

      // --- TOPLU EKLEME/GÃœNCELLEME OPTÄ°MÄ°ZASYONU ---
      int uploadedCount = 0;
      
      // Yeni kayÄ±tlarÄ± ekle
      if (sessionsToInsert.isNotEmpty) {
        final List<Map<String, dynamic>> insertData = [];
        for (final session in sessionsToInsert) {
          final sessionData = session.toJson();
          sessionData.remove('series');
          sessionData.remove('id'); // ID'yi kaldÄ±r, Supabase yeni ID oluÅŸturacak
          insertData.add(sessionData);
        }
        
          try {
            final response = await _supabase
                .from('training_sessions')
              .insert(insertData)
                .select();
          
          // Local'de ID'leri gÃ¼ncelle
          for (int i = 0; i < response.length && i < sessionsToInsert.length; i++) {
              final newId = response[i]['id'] as String?;
            final oldSession = sessionsToInsert[i];
              if (newId != null && newId != oldSession.id) {
                await _db.markSessionAsSynced(oldSession.id, newId);
              }
            }
          uploadedCount += sessionsToInsert.length;
          debugPrint('Successfully inserted ${sessionsToInsert.length} new sessions');
          } catch (e) {
            debugPrint('|10n:sync_supabase_batch_insert_error:$e');
          }
        }
      
      // TOPLU GÃœNCELLEME - BULK UPSERT Ä°LE (Ã‡ok daha hÄ±zlÄ±!)
        if (sessionsToUpdate.isNotEmpty) {
        try {
          debugPrint('ğŸš€ TrainingHistoryService: Bulk updating ${sessionsToUpdate.length} sessions with UPSERT...');
          
          // Toplu upsert iÃ§in session'larÄ± hazÄ±rla
          final bulkUpdateData = sessionsToUpdate.map((sessionData) {
            return {
              'id': sessionData['id'],
              'user_id': sessionData['user_id'],
              'date': sessionData['date'],
              'distance': sessionData['distance'],
              'bow_type': sessionData['bow_type'],
              'is_indoor': sessionData['is_indoor'],
              'training_type': sessionData['training_type'],
              'arrows_per_series': sessionData['arrows_per_series'],
              'series_data': sessionData['series_data'],
              'notes': sessionData['notes'],
              'training_session_name': sessionData['training_session_name'],
              'target_face': sessionData['target_face'],
              'total_arrows': sessionData['total_arrows'] ?? 0, // **FÄ°X: null gÃ¼venlik**
              'total_score': sessionData['total_score'] ?? 0, // **FÄ°X: null gÃ¼venlik**
              'average': sessionData['average'] ?? 0.0, // **FÄ°X: null gÃ¼venlik**
              'x_count': sessionData['x_count'] ?? 0, // **FÄ°X: null gÃ¼venlik**
              'is_deleted': sessionData['is_deleted'] ?? false,
            };
          }).toList();
          
          // **TOPLU UPSERT** - Tek seferde tÃ¼m session'larÄ± gÃ¼ncelle
          await _supabase
              .from('training_sessions')
              .upsert(bulkUpdateData, onConflict: 'id');
          
          uploadedCount += sessionsToUpdate.length;
          debugPrint('âœ… TrainingHistoryService: Bulk upsert completed for ${bulkUpdateData.length} sessions');
          
        } catch (e) {
          debugPrint('âŒ TrainingHistoryService: Bulk upsert error: $e');
          // Hata durumunda fallback: tek tek gÃ¼ncelle
          for (final sessionData in sessionsToUpdate) {
            try {
              await _supabase
                  .from('training_sessions')
                  .update(sessionData)
                  .eq('id', sessionData['id']);
              uploadedCount++;
              debugPrint('Successfully updated session (fallback): ${sessionData['id']}');
            } catch (e) {
              debugPrint('Error updating session ${sessionData['id']}: $e');
            }
          }
        }
      }
      
      // Local'e ekle
      if (onlySupabase.isNotEmpty) {
        final List<TrainingSession> sessionsToSave = [];
        for (final sessionMap in onlySupabase) {
          try {
            final session = TrainingSession.fromJson({
              ...sessionMap,
              'series': sessionMap['training_series'] ?? [],
            });
            if (session.is_deleted == true) {
              debugPrint('|10n:skip_sync_deleted:${session.id}');
              continue;
            }
            sessionsToSave.add(session);
          } catch (e) {
            debugPrint('|10n:sync_local_add_error:${sessionMap['id']}:$e');
          }
        }
        // Local DB'ye toplu ekleme (mÃ¼mkÃ¼nse)
        for (final session in sessionsToSave) {
          await _db.saveTrainingSession(session, markForSync: false); // **FÄ°X: Supabase'den indirilen kayÄ±tlarÄ± sync'e koyma**
          debugPrint('|10n:sync_local_add:${session.id}');
        }
      }
      
      // Senkronizasyon istatistikleri
      debugPrint(
          '|10n:sync_success - Uploaded $uploadedCount sessions, downloaded ${onlySupabase.length} sessions, skipped $skippedCount unchanged');
      return {
        'success': true,
        'uploadedCount': uploadedCount,
        'downloadedCount': onlySupabase.length,
        'skippedCount': skippedCount,
        'error': null
      };
    } catch (e) {
      debugPrint('|10n:sync_general_error:$e');
      return {
        'success': false,
        'uploadedCount': 0,
        'downloadedCount': 0,
        'error': e.toString()
      };
    } finally {
      _isSyncing = false;
    }
  }

  final _supabase = SupabaseConfig.client;
  final DatabaseService _db = DatabaseService();

  // Cache mekanizmasÄ± iÃ§in kullanÄ±lacak statik deÄŸiÅŸkenler
  static final Map<String, List<Map<String, dynamic>>> _trainingHistoryCache =
      {};
  static final Map<String, DateTime> _lastFetchTime = {};

  // Cache iÃ§in geÃ§erlilik sÃ¼resi (10 dakika)
  static const Duration _cacheDuration = Duration(minutes: 10);

  // Cache'in geÃ§erlilik sÃ¼resinin dolup dolmadÄ±ÄŸÄ±nÄ± kontrol eder
  bool _isCacheValid(String cacheKey) {
    if (!_lastFetchTime.containsKey(cacheKey)) {
      return false;
    }

    final lastFetch = _lastFetchTime[cacheKey]!;
    final now = DateTime.now();
    return now.difference(lastFetch) < _cacheDuration;
  }

  // Realtime subscription iÃ§in listener
  void startRealtimeSubscription(String athleteId, Function() onDataChange) {
    debugPrint('Starting realtime subscription for athlete ID: $athleteId');
    _supabase
        .from('training_sessions')
        .stream(primaryKey: ['id'])
        .eq('user_id', athleteId) // filter yerine eq kullanÄ±yoruz
        .listen((data) {
          debugPrint(
              'Received realtime update for training sessions, athleteId: $athleteId');
          clearCacheForAthlete(athleteId);
          onDataChange();
          _syncTrainingDataToLocal(data);
        });
  }

  // Etkilenen antrenmanlarÄ± yenile
  Future<void> _refreshAffectedTrainings(String athleteId,
      List<String> trainingIds, Function() onDataChange) async {
    try {
      // Ä°lgili antrenmanlarÄ± doÄŸrudan Supabase'den Ã§ek
      final response = await _supabase
          .from('training_sessions')
          .select('*')
          .inFilter('id',
              trainingIds) // in_ yerine inFilter kullanÄ±yoruz - Supabase PostgrestFilterBuilder'da doÄŸru metod
          .eq('user_id', athleteId);

      if (response.isNotEmpty) {
        debugPrint('Refreshed ${response.length} affected trainings');
        final trainings = List<Map<String, dynamic>>.from(response);

        // Verileri yerel veritabanÄ±na senkronize et
        await _syncTrainingDataToLocal(trainings);

        // Cache'i temizle ve callback'i Ã§aÄŸÄ±r
        clearCacheForAthlete(athleteId);
        onDataChange();
      }
    } catch (e) {
      debugPrint('Error refreshing affected trainings: $e');
    }
  }

  // Verileri SQLite'a senkronize et
  Future<void> _syncTrainingDataToLocal(
      List<Map<String, dynamic>> trainings) async {
    final db = await _db.database;

    await db.transaction((txn) async {
      for (var training in trainings) {
        // SilinmiÅŸ antrenmanlarÄ± local DB'ye yazma
        if (training['is_deleted'] == true) {
          debugPrint('|10n:skip_sync_deleted:${training['id']}');
          continue;
        }
        debugPrint('Syncing training to local DB: ${training['id']}');

        // Ã–nce verileri iÅŸle - tutarlÄ± hesaplamalar iÃ§in
        _processTrainingData(training);

        // Boolean deÄŸerleri SQLite iÃ§in uygun formata Ã§evir
        final processedTraining = _convertBooleansForSQLite(training);

        // Training session kaydet
        await txn.insert(
          'training_sessions',
          processedTraining,
          conflictAlgorithm: ConflictAlgorithm.replace,
        );
      }
    });
  }

  // Hem online hem de offline mod iÃ§in uygun olan temel metod
  Future<List<Map<String, dynamic>>> getAthleteTrainingHistory(
    String athleteId, {
    bool? isIndoor,
    DateTime? startDate,
    DateTime? endDate,
    bool forceRefresh = false,
  }) async {
    try {
      final cacheKey = _generateCacheKey(athleteId, isIndoor, startDate, endDate);
      
      // **OPTÄ°MÄ°ZASYON:** Cache geÃ§erliyse ve forceRefresh false ise cache'den dÃ¶n
      if (!forceRefresh && _trainingHistoryCache.containsKey(cacheKey) && _isCacheValid(cacheKey)) {
        debugPrint('Cache hit for athlete: $athleteId (${_trainingHistoryCache[cacheKey]!.length} records)');
        return _trainingHistoryCache[cacheKey]!;
      }
      
      // **YENÄ° STRATEJI:** Ã–nce local'den Ã§ek, connectivity varsa background sync
      List<Map<String, dynamic>> localTrainings = [];
      
             // Local verileri Ã§ek (hÄ±zlÄ± response)
       try {
         final localDataRaw = await _getLocalTrainingData(athleteId, isIndoor, startDate, endDate);
         localTrainings = _processLocalTrainingData(localDataRaw);
         debugPrint('Local trainings fetched: ${localTrainings.length} records');
       } catch (e) {
         debugPrint('Error fetching local trainings: $e');
       }
       
       // Background connectivity check ve sync
       final connectivity = await Connectivity().checkConnectivity();
       if (connectivity != ConnectivityResult.none && forceRefresh) {
         try {
           // **SADECE forceRefresh TRUE Ä°SE** Supabase sync yap
           await syncTrainingHistoryWithSupabase(athleteId, force: false); // force: false!
           
           // Sync sonrasÄ± local'den tekrar Ã§ek
           final localDataRawAfterSync = await _getLocalTrainingData(athleteId, isIndoor, startDate, endDate);
           localTrainings = _processLocalTrainingData(localDataRawAfterSync);
           debugPrint('After sync - local trainings: ${localTrainings.length} records');
         } catch (syncError) {
           debugPrint('Background sync failed, using local data: $syncError');
           // Sync baÅŸarÄ±sÄ±z olsa da local data kullan
         }
       }
      
      // Cache'e kaydet ve dÃ¶n
      _trainingHistoryCache[cacheKey] = localTrainings;
      _lastFetchTime[cacheKey] = DateTime.now();
      
      return localTrainings;
    } catch (e) {
      debugPrint('Error in getAthleteTrainingHistory: $e');
      
      // Fallback: Cache'den dÃ¶n veya boÅŸ liste
      final cacheKey = _generateCacheKey(athleteId, isIndoor, startDate, endDate);
      if (_trainingHistoryCache.containsKey(cacheKey)) {
        debugPrint('Using cached data as fallback');
        return _trainingHistoryCache[cacheKey]!;
      }
      
      return [];
    }
  }

  // AynÄ± antrenmana ait birden fazla versiyon varsa sadece en son gÃ¼ncelleneni gÃ¶ster
  List<Map<String, dynamic>> _filterDuplicateTrainings(
      List<Map<String, dynamic>> trainings) {
    debugPrint('Filtering ${trainings.length} trainings for duplicates');

    // Create a map to store trainings by ID - this ensures each training is only shown once
    final Map<String, Map<String, dynamic>> uniqueTrainingsById = {};

    for (var training in trainings) {
      if (training['id'] == null) continue;

      final trainingId = training['id'] as String;

      // Get updated timestamp or fall back to date
      final updatedAt = training['updated_at'] != null
          ? DateTime.parse(training['updated_at'].toString())
          : DateTime.parse(training['date'].toString());

      if (uniqueTrainingsById.containsKey(trainingId)) {
        // If we already have this training ID, keep the newer version
        final existingTraining = uniqueTrainingsById[trainingId]!;
        final existingUpdatedAt = existingTraining['updated_at'] != null
            ? DateTime.parse(existingTraining['updated_at'].toString())
            : DateTime.parse(existingTraining['date'].toString());

        if (updatedAt.isAfter(existingUpdatedAt)) {
          debugPrint('Found newer version of training ID: $trainingId');
          uniqueTrainingsById[trainingId] = training;
        }
      } else {
        // First time seeing this training ID
        uniqueTrainingsById[trainingId] = training;
      }
    }

    // Get the list of unique trainings
    final filteredTrainings = uniqueTrainingsById.values.toList();

    // Sort by date (newest first)
    filteredTrainings.sort((a, b) => DateTime.parse(b['date'].toString())
        .compareTo(DateTime.parse(a['date'].toString())));

    debugPrint(
        'After filtering, ${filteredTrainings.length} unique trainings remain');
    return filteredTrainings;
  }

  // Antrenman verilerini iÅŸleyerek tutarlÄ± hesaplamalar yapar
  void _processTrainingData(Map<String, dynamic> training) {
    // ArtÄ±k training_series kullanÄ±lmÄ±yor, sadece ana antrenman verileri iÅŸleniyor
    // total_arrows, total_score, average gibi alanlar doÄŸrudan kullanÄ±lacak
    // EÄŸer bu alanlar eksikse sÄ±fÄ±rla
    training['total_arrows'] = training['total_arrows'] ?? 0;
    training['total_score'] = training['total_score'] ?? 0;
    training['average'] = training['average'] ?? 0.0;
  }

  // Boolean deÄŸerleri SQLite iÃ§in uygun integer formatÄ±na Ã§evir
  Map<String, dynamic> _convertBooleansForSQLite(Map<String, dynamic> data) {
    final converted = Map<String, dynamic>.from(data);
    
    // Boolean kolonlarÄ± integer'a Ã§evir
    final booleanColumns = ['is_indoor', 'coach_seen', 'is_deleted'];
    
    for (final column in booleanColumns) {
      if (converted.containsKey(column)) {
        final value = converted[column];
        if (value is bool) {
          converted[column] = value ? 1 : 0;
        }
      }
    }
    
    return converted;
  }

  Future<List<Map<String, dynamic>>> _getLocalTrainingData(
    String athleteId,
    bool? isIndoor,
    DateTime? startDate,
    DateTime? endDate,
  ) async {
    final db = await _db.database;
    var query = '''
      SELECT * FROM training_sessions WHERE user_id = ? AND (is_deleted IS NULL OR is_deleted = 0)
    ''';
    var args = [athleteId];
    if (isIndoor != null) {
      query += ' AND is_indoor = ?';
      args.add(isIndoor ? '1' : '0');
    }
    if (startDate != null && endDate != null) {
      query += ' AND date >= ? AND date < ?';
      args.add(startDate.toIso8601String());
      // Add one day to endDate to make it inclusive of the entire end day
      args.add(endDate.add(const Duration(days: 1)).toIso8601String());
    }
    query += ' ORDER BY date DESC';
    final results = await db.rawQuery(query, args);
    debugPrint('Retrieved ${results.length} local training records for athlete $athleteId (excluding deleted)');
    return results;
  }

  // Yerel veritabanÄ±ndan alÄ±nan verileri iÅŸle
  List<Map<String, dynamic>> _processLocalTrainingData(
      List<Map<String, dynamic>> results) {
    // ArtÄ±k training_series yok, sadece ana antrenman verileri iÅŸleniyor
    return results.where((row) {
      // is_deleted alanÄ± hem int hem bool hem de null olabilir
      final isDeleted = row['is_deleted'];
      return isDeleted == null || isDeleted == false || isDeleted == 0;
    }).map((row) {
      final training = {
        ...Map<String, dynamic>.from(row),
        'is_indoor': row['is_indoor'] == 1 || row['is_indoor'] == true,
        'total_arrows': row['total_arrows'] ?? 0,
        'total_score': row['total_score'] ?? 0,
        'average': row['average'] ?? 0.0,
      };
      return training;
    }).toList();
  }

  // TÃ¼m yerel antrenman listesini iÅŸleyerek daha iyi veri tutarlÄ±lÄ±ÄŸÄ± saÄŸla
  List<Map<String, dynamic>> _processLocalTrainingList(
      List<Map<String, dynamic>> results) {
    // Sadece ana antrenman verileri iÅŸleniyor
    final processedList = _processLocalTrainingData(results);
    for (var training in processedList) {
      _processTrainingData(training);
    }
    return processedList;
  }

  // Ä°nternet baÄŸlantÄ±sÄ±nÄ± kontrol et - daha gÃ¼venilir yÃ¶ntem
  Future<bool> _hasInternetConnection() async {
    try {
      // Ã–nce connectivity_plus ile kontrol et
      var connectivityResult = await Connectivity().checkConnectivity();
      if (connectivityResult == ConnectivityResult.none) {
        return false;
      }

      // GerÃ§ek baÄŸlantÄ±yÄ± test et
      final result = await InternetAddress.lookup('google.com')
          .timeout(const Duration(seconds: 3));
      return result.isNotEmpty && result[0].rawAddress.isNotEmpty;
    } catch (e) {
      debugPrint('Internet connection check failed: $e');
      return false;
    }
  }

  // Cache key oluÅŸturma yardÄ±mcÄ± metodu
  String _generateCacheKey(
    String athleteId,
    bool? isIndoor,
    DateTime? startDate,
    DateTime? endDate,
  ) {
    return '$athleteId:${isIndoor?.toString() ?? "all"}:${startDate?.toIso8601String() ?? ""}:${endDate?.toIso8601String() ?? ""}';
  }

  // Belirli bir sporcu iÃ§in cache'i temizle
  void clearCacheForAthlete(String athleteId) {
    debugPrint('Clearing cache for athlete: $athleteId');
    _trainingHistoryCache.removeWhere((key, _) => key.startsWith(athleteId));
    _lastFetchTime.removeWhere((key, _) => key.startsWith(athleteId));

    // Web platformunda SQLite kullanÄ±lamaz, bu nedenle bu kÄ±smÄ± atlÄ±yoruz
    if (kIsWeb) {
      debugPrint(
          'Web platform: Skipping SQLite operations in clearCacheForAthlete');
      return;
    }

    // Not: training_series tablosu artÄ±k kullanÄ±lmÄ±yor, seriler series_data JSON alanÄ±nda tutuluyor
    // Bu yÃ¼zden eski seri temizleme kodunu kaldÄ±rÄ±yoruz
    debugPrint('Cache cleared for athlete: $athleteId (series cleanup skipped - using JSON storage)');
  }

  // Tarih aralÄ±ÄŸÄ±na gÃ¶re antrenman verilerini getir
  Future<List<Map<String, dynamic>>> getTrainingsInDateRange(
    String athleteId,
    DateTime startDate,
    DateTime endDate, {
    bool? isIndoor,
  }) async {
    return getAthleteTrainingHistory(
      athleteId,
      isIndoor: isIndoor,
      startDate: startDate,
      endDate: endDate,
      forceRefresh: true,
    );
  }

  // AntrenÃ¶r iÃ§in antrenman gÃ¶rÃ¼ntÃ¼leme - sporcu ve antrenÃ¶rÃ¼n aynÄ± verileri gÃ¶rmesini saÄŸlar
  Future<List<Map<String, dynamic>>> getTrainerViewOfAthleteTrainings(
    String athleteId, {
    bool? isIndoor,
    DateTime? startDate,
    DateTime? endDate,
    bool forceRefresh =
        false, // VarsayÄ±lan deÄŸeri false, gereksiz yÃ¼klemeyi Ã¶nlemek iÃ§in
  }) async {
    debugPrint(
        'getTrainerViewOfAthleteTrainings: athleteId=$athleteId, isIndoor=$isIndoor, startDate=$startDate, endDate=$endDate, force=$forceRefresh');

    final cacheKey = _generateCacheKey(athleteId, isIndoor, startDate, endDate);

    // Ã–nce cache kontrolÃ¼ yap
    if (!forceRefresh &&
        _trainingHistoryCache.containsKey(cacheKey) &&
        _isCacheValid(cacheKey)) {
      debugPrint('Returning cached training data for coach view');
      // Always filter out deleted trainings from cache
      final cached = _trainingHistoryCache[cacheKey]!;
      return cached.where((training) => training['is_deleted'] != true).toList();
    }

    try {
      // Verileri al
      List<Map<String, dynamic>> trainings = await getAthleteTrainingHistory(
        athleteId,
        isIndoor: isIndoor,
        startDate: startDate,
        endDate: endDate,
        forceRefresh: forceRefresh,
      );

      // Filtreleme iÅŸlemlerini manuel olarak uygula (veritabanÄ±nda doÄŸru Ã§alÄ±ÅŸmama ihtimaline karÅŸÄ±)
      if (isIndoor != null) {
        debugPrint('Manually filtering for isIndoor=$isIndoor');
        trainings = trainings
            .where((training) => (training['is_indoor'] == isIndoor))
            .toList();
      }

      if (startDate != null && endDate != null) {
        debugPrint('Manually filtering for date range: $startDate to $endDate');
        trainings = trainings.where((training) {
          final trainingDate = DateTime.parse(training['date'].toString());
          // Tarih aralÄ±ÄŸÄ±nÄ± kontrol et: startDate <= trainingDate <= endDate
          return (trainingDate.isAtSameMomentAs(startDate) ||
                  trainingDate.isAfter(startDate)) &&
              (trainingDate.isAtSameMomentAs(endDate) ||
                  trainingDate.isBefore(endDate.add(const Duration(days: 1))));
        }).toList();
      }

      debugPrint('After filtering, training count: ${trainings.length}');

      // Her antrenman iÃ§in tutarlÄ± hesaplamalarÄ± garantile
      for (var training in trainings) {
        _processTrainingData(training);
      }

      // Cache'i gÃ¼ncelle
      _trainingHistoryCache[cacheKey] = trainings;
      _lastFetchTime[cacheKey] = DateTime.now();

      return trainings;
    } catch (e) {
      debugPrint('Error in getTrainerViewOfAthleteTrainings: $e');

      // Hata durumunda cache'de veri varsa onu kullan
      if (_trainingHistoryCache.containsKey(cacheKey)) {
        return _trainingHistoryCache[cacheKey]!;
      }

      // Cache'de de yoksa boÅŸ liste dÃ¶n
      return [];
    }
  }

  // Lokal antrenman verilerini dÃ¼zeltmek iÃ§in - artÄ±k _processTrainingData kullanÄ±yor
  List<Map<String, dynamic>> _correctLocalTrainingData(
      List<Map<String, dynamic>> trainings) {
    for (var training in trainings) {
      _processTrainingData(training);
    }
    return trainings;
  }

  // AntrenÃ¶r iÃ§in Ã¶zel realtime subscription baÅŸlatma metodu
  void startCoachRealtimeSubscription(
      String athleteId, Function() onDataChange) {
    debugPrint(
        'Starting COACH realtime subscription for athlete ID: $athleteId');

    // Web: Supabase Realtime stream kullan (polling yerine)
    if (kIsWeb) {
      _supabase
          .from('training_sessions')
          .stream(primaryKey: ['id'])
          .eq('user_id', athleteId)
          .listen((data) {
        debugPrint('Web Realtime: Training session changed for athlete $athleteId');
        // Sadece cache temizle ve callback Ã§aÄŸÄ±r; SQLite iÅŸlemi yok
        clearCacheForAthlete(athleteId);
        onDataChange();
      });
      return;
    }

    // Mobil platformlar iÃ§in realtime subscription kullan
    // Training sessions deÄŸiÅŸikliklerini dinle (silinen antrenmanlarÄ± da yakalamak iÃ§in filtre yok)
    _supabase
        .from('training_sessions')
        .stream(primaryKey: ['id'])
        .eq('user_id', athleteId)
        .listen((data) {
          debugPrint(
              'Coach Realtime: Training session changed for athlete $athleteId');

          // Silinen antrenmanlarÄ± handle et
          final List<Map<String, dynamic>> activeData = [];
          final List<String> deletedIds = [];
          
          for (final item in data) {
            final isDeleted = item['is_deleted'] == true || item['is_deleted'] == 1;
            if (isDeleted) {
              deletedIds.add(item['id'] as String);
              debugPrint('Coach Realtime: Found deleted training: ${item['id']}');
            } else {
              activeData.add(item);
            }
          }
          
          // Silinen antrenmanlarÄ± local'de de sil
          for (final deletedId in deletedIds) {
            debugPrint('Coach Realtime: Soft deleting training locally: $deletedId');
            _db.softDeleteTrainingSession(deletedId);
          }
          
          // Active antrenmanlarÄ± sync et
          if (activeData.isNotEmpty) {
            _syncTrainingDataToLocal(activeData);
          }

          // Her durumda cache'i temizle ve callback'i Ã§aÄŸÄ±r (silinen antrenmanlar iÃ§in de UI gÃ¼ncellensin)
          clearCacheForAthlete(athleteId);
          onDataChange();
        });
  }

  Future<void> validateSeriesArrows(String trainingId, List<int> arrows) async {
    try {
      // Get training session details including arrows_per_series
      final training = await getTrainingDetailsForCoach(trainingId);
      final arrowsPerSeries =
          training['arrows_per_series'] ?? 6; // Default to 6 if not set

      if (arrows.length != arrowsPerSeries) {
        throw Exception(
            'Her seri iÃ§in tam olarak $arrowsPerSeries ok girilmelidir. Åu an ${arrows.length} ok girildi.');
      }

      // Validate arrow scores (should be between -1 and 11, where -1 and 11 represent X)
      for (final arrow in arrows) {
        if (arrow < -1 || arrow > 11) {
          throw Exception(
              'GeÃ§ersiz ok puanÄ±: $arrow. Puanlar -1 ile 11arasÄ±na olmalÄ±dÄ±r.');
        }
      }
    } catch (e) {
      debugPrint('Error validating series arrows: $e');
      rethrow;
    }
  }

  Future<Map<String, dynamic>> getTrainingDetailsForCoach(
      String trainingId) async {
    if (kIsWeb) {
      // Web platformunda sadece Supabase'den veri Ã§ek
      try {
        final trainingResponse = await _supabase
            .from('training_sessions')
            .select()
            .eq('id', trainingId)
            .single();
        final training = Map<String, dynamic>.from(trainingResponse);
        _processTrainingData(training);
        return training;
      } catch (e) {
        debugPrint('Error fetching training details for coach (web): $e');
        rethrow;
      }
    }
    try {
      debugPrint('Fetching training details for coach, training ID: $trainingId');
      final db = await _db.database;
      final trainingQuery = await db.query(
        'training_sessions',
        where: 'id = ?',
        whereArgs: [trainingId],
      );
      if (trainingQuery.isEmpty) {
        debugPrint('Training not found in local database, fetching from Supabase');
        if (await _hasInternetConnection()) {
          final trainingResponse = await _supabase
              .from('training_sessions')
              .select()
              .eq('id', trainingId)
              .single();
          final training = Map<String, dynamic>.from(trainingResponse);
          _processTrainingData(training);
          await _syncTrainingDataToLocal([training]);
          return training;
        } else {
          throw Exception('Antrenman verisi bulunamadÄ± ve internet baÄŸlantÄ±sÄ± yok');
        }
      }
      final training = Map<String, dynamic>.from(trainingQuery.first);
      training['is_indoor'] = training['is_indoor'] == 1;
      _processTrainingData(training);
      if (await _hasInternetConnection()) {
        _refreshTrainingInBackground(trainingId);
      }
      return training;
    } catch (e) {
      debugPrint('Error fetching training details for coach: $e');
      rethrow;
    }
  }

  // Refresh training data in background without blocking
  Future<void> _refreshTrainingInBackground(String trainingId) async {
    try {
      final trainingResponse = await _supabase
          .from('training_sessions')
          .select()
          .eq('id', trainingId)
          .single();

      final training = Map<String, dynamic>.from(trainingResponse);

      // Process and save to local database
      _processTrainingData(training);
      await _syncTrainingDataToLocal([training]);

      debugPrint('Training $trainingId refreshed in background');
    } catch (e) {
      debugPrint('Background refresh error: $e');
    }
  }

  // Antrenman verilerinin hash deÄŸerini oluÅŸtur - verilerde deÄŸiÅŸiklik kontrolÃ¼ iÃ§in
  String _generateTrainingDataHash(
      List<Map<String, dynamic>> trainingSessions) {
    // Basit bir hash - tÃ¼m eÄŸitim ID'lerini ve updated_at deÄŸerlerini birleÅŸtir
    final buffer = StringBuffer();

    // ID'leri ve son gÃ¼ncelleme zamanlarÄ±nÄ± sÄ±rala ve birleÅŸtir
    final items = [];
    for (final training in trainingSessions) {
      final id = training['id'] as String;
      final updatedAt = training['updated_at'] ?? training['date'] ?? '';
      items.add('$id:$updatedAt');
    }

    // Hash deÄŸerini oluÅŸtur
    items.sort(); // SÄ±ralama ile tutarlÄ±lÄ±k saÄŸla
    buffer.writeAll(items, ',');
    return buffer.toString();
  }

  // Son eÄŸitim verileri hash deÄŸerlerini sakla
  final Map<String, String> _lastTrainingDataHashes = {};

  // Web platformu iÃ§in polling yaklaÅŸÄ±mÄ± - Realtime subscription'larÄ±n yerine kullanÄ±lÄ±r
  Future<void> _pollAthleteTrainingData(
      String athleteId, Function() onDataChange) async {
    try {
      debugPrint('Web platform: Polling training data for athlete $athleteId');

      // Direkt olarak Supabase'den verileri Ã§ek (silinen antrenmanlarÄ± filtrele)
      final response = await _supabase
          .from('training_sessions')
          .select('*')
          .eq('user_id', athleteId)
          .eq('is_deleted', false)
          .order('date', ascending: false);

      final data = List<Map<String, dynamic>>.from(response);

      // Verilerin hash deÄŸerini oluÅŸtur
      final newDataHash = _generateTrainingDataHash(data);
      final lastHash = _lastTrainingDataHashes[athleteId];

      // Veriler deÄŸiÅŸtiyse veya ilk kez alÄ±nÄ±yorsa iÅŸle
      if (lastHash == null || newDataHash != lastHash) {
        debugPrint('Web platform: Training data changed, updating UI');

        // Hash'i gÃ¼ncelle
        _lastTrainingDataHashes[athleteId] = newDataHash;

        debugPrint(
            'Web platform: Retrieved ${data.length} training sessions for athlete');

        // Verileri iÅŸle
        for (var training in data) {
          _processTrainingData(training);
        }

        // Web platformu iÃ§in memory cache'i gÃ¼ncelle
        final cacheKey = _generateCacheKey(athleteId, null, null, null);
        _trainingHistoryCache[cacheKey] = data;
        _lastFetchTime[cacheKey] = DateTime.now();

        // Callback'i Ã§aÄŸÄ±r - UI'Ä± gÃ¼ncellemek iÃ§in
        onDataChange();
      } else {
        debugPrint(
            'Web platform: No changes detected in training data, skipping update');
      }
    } catch (e) {
      debugPrint('Web platform: Error polling training data: $e');
    }
  }

  // Duplicate Session ID hatalarÄ± iÃ§in Ã¶zel fonksiyon
  // Bu fonksiyon SADECE gerÃ§ek Ã§akÄ±ÅŸmalarda Ã§alÄ±ÅŸÄ±r (aynÄ± ID, farklÄ± iÃ§erik)
  // Normal sync durumlarÄ±nda (aynÄ± ID, aynÄ± iÃ§erik) Ã‡ALIÅMAZ
  Future<void> _handleDuplicateTrainingIds(String athleteId) async {
    try {
      debugPrint('Checking for genuine content conflicts...');
      
      // **Ã–NEMLÄ°:** Sadece pending_sync=1 olan kayÄ±tlarÄ± kontrol et
      // Ã‡Ã¼nkÃ¼ sadece bunlar Supabase'e gÃ¶nderilmeye Ã§alÄ±ÅŸÄ±lÄ±yor
      final allLocalTrainings = await _db.getUserTrainingSessions(athleteId);
      final localPendingTrainings = allLocalTrainings.where((s) {
        // TrainingSession modelinde pendingSync Ã¶zelliÄŸi yoksa, raw data'dan kontrol et
        final raw = s.toJson(); 
        return (raw['pending_sync'] == 1 || raw['pending_sync'] == true);
      }).toList();
      
      if (localPendingTrainings.isEmpty) {
        debugPrint('No pending local trainings to check for conflicts.');
        return;
      }

      // Sadece pending kayÄ±tlarÄ±n ID'lerini kontrol et
      final pendingIds = localPendingTrainings
          .where((t) => !t.id.startsWith('local_')) // Local ID'ler zaten gÃ¼venli
          .map((t) => t.id)
          .toList();
          
      if (pendingIds.isEmpty) {
        debugPrint('No non-local pending IDs to check.');
        return;
      }

      // Supabase'de aynÄ± ID'lere sahip kayÄ±tlarÄ± al
      final supabaseResponse = await _supabase
          .from('training_sessions')
          .select('*')
          .eq('user_id', athleteId)
          .inFilter('id', pendingIds);

      final supabaseTrainings = (supabaseResponse as List);
      
      if (supabaseTrainings.isEmpty) {
        debugPrint('No conflicts found - all pending IDs are safe to upload.');
        return;
      }

      // **GERÃ‡EK Ã‡AKIÅMA KONTROLÃœ:**
      // AynÄ± ID'ye sahip ama FARKLI Ä°Ã‡ERÄ°ÄE sahip kayÄ±tlarÄ± bul
      final genuineConflicts = <String>[];
      
      for (final localTraining in localPendingTrainings) {
        final supabaseMatch = supabaseTrainings
            .where((s) => s['id'] == localTraining.id)
            .firstOrNull;
            
        if (supabaseMatch != null) {
          // Ä°Ã§erik karÅŸÄ±laÅŸtÄ±rmasÄ± - sadece Ã¶nemli alanlarÄ± kontrol et
          final localDate = localTraining.date.toIso8601String();
          final supabaseDate = supabaseMatch['date'] as String?;
          final localSeriesData = localTraining.seriesData;
          final supabaseSeriesData = supabaseMatch['series_data'];
          
          // EÄŸer tarih VEYA series_data farklÄ±ysa = gerÃ§ek Ã§akÄ±ÅŸma
          if (localDate != supabaseDate || 
              localSeriesData != supabaseSeriesData) {
            genuineConflicts.add(localTraining.id);
            debugPrint('Genuine conflict detected for ID: ${localTraining.id}');
            debugPrint('  Local date: $localDate vs Supabase date: $supabaseDate');
            debugPrint('  Content differs - will rename local copy');
          } else {
            debugPrint('Same content for ID: ${localTraining.id} - no conflict');
          }
        }
      }

      if (genuineConflicts.isNotEmpty) {
        debugPrint('Found ${genuineConflicts.length} genuine content conflicts!');

        // SADECE gerÃ§ek Ã§akÄ±ÅŸmalarÄ± rename et
        for (final id in genuineConflicts) {
          try {
            final newId = 'local_${DateTime.now().millisecondsSinceEpoch}_$id';
            debugPrint('Renaming conflicted training: $id â†’ $newId');

            await _db.markSessionAsSynced(id, newId);
          } catch (e) {
            debugPrint('Error renaming conflicted ID $id: $e');
          }
        }
      } else {
        debugPrint('No genuine conflicts found - all same content as Supabase.');
      }
    } catch (e) {
      debugPrint('Error checking for genuine conflicts: $e');
    }
  }

  // Yerel veritabanÄ±ndaki antrenman oturumlarÄ±nÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in yardÄ±mcÄ± fonksiyon
  Future<List<Map<String, dynamic>>> showLocalTrainingSessions(
      String userId) async {
    try {
      final db = await _db.database;

      // Antrenman oturumlarÄ±nÄ± al
      final sessions = await db.query('training_sessions',
          where: 'user_id = ? AND (is_deleted IS NULL OR is_deleted = 0)',
          whereArgs: [userId],
          orderBy: 'date DESC');

      // Her oturum iÃ§in serileri al ve birleÅŸtir
      final result = <Map<String, dynamic>>[];

      for (final session in sessions) {
        result.add({
          ...session,
          'series_count': 0,
          'id_type': session['id'].toString().startsWith('local_')
              ? 'local'
              : 'remote',
          'sync_status': session['pending_sync'] == 1 ? 'pending' : 'synced',
        });
      }

      debugPrint(
          'Found ${result.length} local training sessions for user $userId');
      return result;
    } catch (e) {
      debugPrint('Error showing local training sessions: $e');
      return [];
    }
  }

  /// Manuel olarak tÃ¼m antrenman verilerini senkronize eder
  ///
  /// `userId`: Senkronize edilecek kullanÄ±cÄ±nÄ±n ID'si
  ///
  /// DÃ¶nÃ¼ÅŸ DeÄŸeri: Ä°ÅŸlem sonucu ve istatistikler
  Future<Map<String, dynamic>> manualSyncTrainingData(String userId) async {
    // Manuel senkronizasyonda her zaman force=true kullan
    return await syncTrainingHistoryWithSupabase(userId, force: true);
  }

  /// Sadece tek bir antrenman oturumunu senkronize eder
  ///
  /// `trainingId`: Senkronize edilecek antrenmanÄ±n ID'si
  /// DÃ¶nÃ¼ÅŸ DeÄŸeri: BaÅŸarÄ±lÄ± olursa true, baÅŸarÄ±sÄ±z olursa false dÃ¶ner
  Future<bool> syncSingleTrainingSession(String trainingId) async {
    try {
      // EÄŸer ID local_ ile baÅŸlÄ±yorsa veya boÅŸsa, toplu sync tetikle ve Ã§Ä±k
      if (trainingId.isEmpty || trainingId.startsWith('local_')) {
        debugPrint('Single sync: Skipping invalid or local ID ($trainingId), triggering batch sync instead.');
        await syncTrainingHistoryWithSupabase(await _getCurrentUserId(), force: true);
        return false;
      }
      final db = await _db.database;
      // AntrenmanÄ± localden al
      final sessions = await db.query(
        'training_sessions',
        where: 'id = ?',
        whereArgs: [trainingId],
      );
      if (sessions.isEmpty) {
        debugPrint('No local session found with id: $trainingId');
        return false;
      }
      final session = sessions.first;
      // --- Zero-arrow session kontrolÃ¼ ---
      if (session['series_data'] == null || session['series_data'].toString().isEmpty) {
        debugPrint('Single sync: Skipping session with zero arrows: $trainingId');
        return false;
      }
      // Supabase'de var mÄ± kontrol et
      final existing = await _supabase
          .from('training_sessions')
          .select('id')
          .eq('id', trainingId)
          .maybeSingle();
      if (existing == null) {
        // Yoksa ekle
        final insertResponse = await _supabase
            .from('training_sessions')
            .insert(session)
            .select();
        if (insertResponse.isNotEmpty) {
          final newId = insertResponse[0]['id'];
          if (newId != null && newId != trainingId) {
            await _db.markSessionAsSynced(trainingId, newId);
          }
          return true;
        }
      } else {
        // Varsa gÃ¼ncelle
        await _supabase
            .from('training_sessions')
            .update(session)
            .eq('id', trainingId);
        return true;
      }
    } catch (e) {
      debugPrint('Error syncing single session: $e');
    }
    return false;
  }

  // KullanÄ±cÄ± ID'sini almak iÃ§in yardÄ±mcÄ± fonksiyon (gerekirse)
  Future<String> _getCurrentUserId() async {
    try {
      final user = SupabaseConfig.client.auth.currentUser;
      if (user != null) return user.id;
    } catch (_) {}
    return '';
  }

  // Veri deÄŸiÅŸikliklerini kontrol eden yardÄ±mcÄ± fonksiyon
  bool _hasDataChanges(TrainingSession localSession, Map<String, dynamic> supabaseData) {
    try {
      // Ana alanlarÄ± karÅŸÄ±laÅŸtÄ±r - sadece gerÃ§ekten Ã¶nemli olanlarÄ±
      final criticalFields = [
        'series_data', // En Ã¶nemli alan - ok atÄ±ÅŸlarÄ±
        'training_session_name', 
        'notes', 
        'distance', 
        'bow_type', 
        'is_indoor', 
        'training_type',
        'arrows_per_series'
      ];
      
      // **Ã–NEMLÄ°:** total_score, total_arrows, average gibi hesaplanan alanlarÄ± karÅŸÄ±laÅŸtÄ±rma
      // Ã‡Ã¼nkÃ¼ bunlar null/0 farkÄ± gÃ¶sterebilir ve gerÃ§ek deÄŸiÅŸiklik deÄŸildir
      
      for (final field in criticalFields) {
        final localValue = _normalizeValue(localSession.toJson()[field]);
        final supabaseValue = _normalizeValue(supabaseData[field]);
        
        if (localValue != supabaseValue) {
          debugPrint('ğŸ’¡ Critical field difference in $field: local=$localValue vs supabase=$supabaseValue');
          return true;
        }
      }
      
      return false;
    } catch (e) {
      debugPrint('Error comparing data: $e');
      return false; // **FÄ°X: Hata durumunda gÃ¼ncelleme yapma**
    }
  }
  
  // DeÄŸerleri karÅŸÄ±laÅŸtÄ±rma iÃ§in normalize et
  dynamic _normalizeValue(dynamic value) {
    if (value == null) return 0; // **FÄ°X: null deÄŸerlerini 0 olarak kabul et**
    
    // **FÄ°X: Boolean deÄŸerleri normalize et**
    if (value is bool) return value;
    if (value is num) {
      // **FÄ°X: 0/1 deÄŸerlerini boolean'a Ã§evir (is_indoor, is_deleted gibi alanlar iÃ§in)**
      if (value == 0 || value == 1) {
        return value == 1; // 1 -> true, 0 -> false
      }
      return value == 0 ? 0 : value.toDouble();
    }
    
    if (value is String) {
      if (value.isEmpty) return 0; // **FÄ°X: boÅŸ string'i 0 olarak kabul et**
      // Boolean string'lerini kontrol et
      if (value.toLowerCase() == 'true') return true;
      if (value.toLowerCase() == 'false') return false;
      // SayÄ± string'i varsa parse et
      final parsed = double.tryParse(value);
      if (parsed != null) {
        // SayÄ± ise ve 0/1 ise boolean'a Ã§evir
        if (parsed == 0 || parsed == 1) {
          return parsed == 1;
        }
        return parsed == 0 ? 0 : parsed;
      }
      return value;
    }
    return value;
  }
}
